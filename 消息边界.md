<!--
 * @Author: 千铭天
 * @Date: 2019-10-24 21:36:35
 * @LastEditors: 
 * @LastEditTime: 2019-10-24 23:07:52
 * @Description:  
 -->
# **消息边界**

## TCP数据发送与UDP接收

在socket网络程序中，TCP和UDP分别是面向连接和非面向连接的。因此TCP的socket编程，收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包(多次间隔较小且数据量小的数据)，更有效的发到对方，使用了优化方法（Nagle算法）合并成一个大的数据块，然后进行封包。这样，接收端就难于分辨出来封装再一起的多个小块数据，必须提供科学的拆包机制。

对于UDP，不会使用块的合并优化算法，这样，实际上目前认为，是由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。

## 保护消息边界和流

那么什么是保护消息边界和流呢?

**保护消息边界**，就是指传输协议把数据当作一条独立的消息在网上传输,接收端只能接收独立的消息.也就是*说存在保护消息边界*,接收端一次只能接收发送端发出的一个数据包.

而**面向流**则是指*无保护消息保护边界*的,如果发送端连续发送数据,接收端有可能在一次接收动作中,会接收两个或者更多的数据包.

我们举个例子来说,例如,我们连续发送三个数据包,大小分别是2k,4k, 8k,这三个数据包,都已经到达了接收端的网络堆栈中：

    如果使用UDP协议,不管我们使用多大的接收缓冲区去接收数据,我们必须有三次接收动作,才能够把所有的数据包接收完.

    而使用TCP协议,我们只要把接收的缓冲区大小设置在14k以上,我们就能够一次把所有的数据包接收下来.只需要有一次接收动作.

    这就是因为UDP协议的保护消息边界使得每一个消息都是独立的.而流传输,却把数据当作一串数据流,他不认为数据是一个一个的消息.

所以有很多人在使用tcp协议通讯的时候,并不清楚**tcp是基于流的传输,传输的最小单位为一个报文段（segment）**,当连续发送数据的时候,他们时常会认识tcp会丢包.其实不然,因为当他们使用的缓冲区足够大时,他们有可能会一次接收到两个甚至更多的数据包,而很多人往往会忽视这一点,只解析检查了第一个数据包,而已经接收的其他数据包却被忽略了.所以大家如果要作这类的网络编程的时候,必须要注意这一点.

TCP的一个缓冲区可以存储多个数据包，由于并不会认为每一个数据包时分离的，缓冲区里面的数据包是需要应用程序根据数据包里的数据包的长度字段信息进行分离开来的。

> 在电路交换与虚电路网络中，一个应用程序可能需要发送几块数据，接收程序将所有数据作为一个或多个块来读取。这种类型的协议不保留消息边界。在底层协议不保留消息边界，而应用程序在需要他的情况下，应用程序必须自己来提供这个功能。--《TCP/IP详解 第二版》 pp.3

[**结论：** ](https://blog.csdn.net/zhangxinrun/article/details/6721427) 

根据以上所说，可以这样理解，TCP为了保证可靠传输，尽量减少额外
开销（每次发包都要验证），因此采用了流式传输，面向流的传输，
相对于面向消息的传输，可以减少发送包的数量（收集到足够多的消息数据后才发送一包数据）。从而减少了额外开销。但是，对于数据传输频繁的程序来讲，使用TCP可能会容易粘包。当然，对接收端的程序来讲，如果机器负荷很重，也会在接收缓冲里粘包。这样，就需要接收端额外拆包，增加了工作量。因此，这个特别适合的是数据要求可靠传输，但是不需要太频繁传输的场合（两次操作间隔100ms，具体是由TCP等待发送间隔决定的，取决于内核中的socket的写法）


而UDP，由于面向的是消息传输，它把所有接收到的消息都挂接到缓冲
区的接受队列中，因此，它对于数据的提取分离就更加方便，但是，
它没有粘包机制，因此，当发送数据量较小的时候，就会发生数据包
有效载荷较小的情况，也会增加多次发送的系统发送开销（系统调用，
写硬件等）和接收开销。因此，应该最好设置一个比较合适的数据包
的包长，来进行UDP数据的发送。（UDP最大载荷为1472，因此最好能
每次传输接近这个数的数据量，这特别适合于视频，音频等大块数据
的发送，同时，通过减少握手来保证流媒体的实时性）

## 参考资料
1. [TCP和UDP的"保护消息边界" （经典）](https://blog.csdn.net/zhangxinrun/article/details/6721427)
2. 《TCP/IP详解 第二版》 pp.3
3. [tcp粘包和拆包的原因及处理方案](https://www.cnblogs.com/hpu001/p/9925573.html)

[下一篇](消息边界.md)